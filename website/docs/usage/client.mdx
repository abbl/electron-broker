---
sidebar_position: 2
---

# Client
As opposed to usage of multiple Event Emitters (such as `ipcMain` or `ipcRenderer`),
broker exposes single `BrokerClient` class. Which acts as universal message broadcaster on every process.
It also does not accept multiple arguments as a message content, it uses one argument instead.

Building of `BrokerClient` object is done by usage of `Broker` class method called `createClient()`. 
Each instance it returns is **unique**. Therefore, middleware bound to one instance, won't be present 
in another one.  

```typescript {14} title="index.tsx"
import "reflect-metadata";
import { BrokerClient, Broker } from 'electron-broker';

let broker: Broker;
let client: BrokerClient;

async function createBroker() {
  broker = await BrokerFactory.createRendererBroker({
    secure: true,
  });

  broker.start();

  client = broker.createClient();
}
```

## Send
Synchronously emits message on specific pattern, and does not listen for the 
response. It takes the pattern as first arguement, and payload as the second one. 

```typescript {5} title="send.ts"
function incrementByValue(): void {
  const pattern = 'increment-by-value';
  const payload = { value: 2136.99 };

  broker.send(pattern, payload);
}
```
:::info
The `send()` method only triggers `onRequest()` part of `Middleware` interface.
:::


## Invoke
Asynchronously emits the message on specific pattern, and listens for the response.
It takes the pattern as first arguement, and payload as second one.

```typescript {5} title="invoke.ts"
async function checkWeather(): Promise<string> {
  const pattern = 'check-weather';
  const payload = { city: "Warsaw" }; 

  return broker.invoke(pattern, payload);
}

const weather = await checkWeather();
```

## InvokeRaw
Asynchronously emits the message on specific pattern, and listens for the response.
But upon response, it returns the `BrokerEvent` object instead of its `data` property, as in `invoke()` method. 

```typescript {5} title="invoke-raw.ts"
async function checkWeatherRaw(): Promise<BrokerEvent> {
  const pattern = 'check-weather';
  const payload = { city: "Warsaw" };
  
  return broker.invokeRaw(pattern, payload);
}

const brokerEvent = await checkWeatherRaw();

// Access the results of the message
console.log(brokerEvent.data);
```

## Subscribe
Creates the subscriber, which listens for message on specific pattern by usage listener function.

```typescript title="subscriber.ts"
interface UserSessionDto {
  username: string;
}

const oneTimeSubscriber = broker.subscribe<UserSessionDto>(
  'user-session-start', 
  (data, brokerEvent) => { // brokerEvent arguement is optional.
    console.log(`[LOG] Session for user ${data.username} has been initialised.`)
    
    // Remove the subscription after receiving the message. 
    subscriber.unsubscribe();
  }
)
```

:::info
  Messages received through subscriber **don't** trigger the execution of middlewares.
:::

## SetMiddleware
Sets the middleware, that will be executed after usage of `send()`, `invoke()` and `invokeRaw()` methods.

```typescript title="middleware.ts"
import {BrokerClient, Middleware, ExecutionContext} from 'electron-broker';

class MessageLogMiddleware implements Middleware {
  public onRequest(context: ExecutionContext) {
    const { eventId } = context.brokerEvent;

    console.log(`[LOG] Sent message with eventId: ${eventId}`)    
  }

  public onResponse(context: ExecutionContext) {
    const { eventId } = context.brokerEvent;

    console.log(`[LOG] Received message with eventId: ${eventId}`)    
  }
}

brokerClient.setMiddleware([new MessageLogMiddleware()])
```



